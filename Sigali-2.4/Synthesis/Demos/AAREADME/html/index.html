<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>AAREADME: Supervisory Control Problem: An overview of the examples</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
  </ul></div>
<h1>Supervisory Control Problem: An overview of the examples</h1>
<p>
Contents:<ul>
<li><a class="el" href="index.html#sectA">Directory contents</a></li><li><a class="el" href="index.html#sectB">How to rebuild the complete demo</a></li><li><a class="el" href="index.html#sectC">Principles of the technique</a></li></ul>
<h2><a class="anchor" name="sectA">
Directory contents</a></h2>
All the examples are built on the same scheme. In each directory (CAT_AND_MOUSE, AGV, ...) you will find the following content:<p>
<ul>
<li><b>AAREADME</b> The directory of the documentation.</li></ul>
<p>
<ul>
<li><b>vt.gpk</b> is the main Signal file. It has to be loaded by the graphical user interface "polychrony". This Signal program contains different processes. <br>
 |<br>
 |- CONTEXT: used to perform Simulation <br>
 |<br>
 |- VT_<em>Foo:</em> your application<br>
 |<br>
 |- vt: This process is simply the process VT_<em>Foo</em> to which you add some SIGALI functions and/or some assertions that have to be checked by the inputs. The name is the same for technical reasons than the main program. This is this one that you have to compile in order to obtain the corresponding polynomial dynamical system on which synthesis will be performed.</li></ul>
<p>
<ul>
<li><b>vt.sim</b>, <b>vt.res</b> are file generated by Sigali in order to perform simulation. They contains in a internal format the result of the sigali computations (i.e. the controller). They will be used by the polychrony tool to encapsulate the controller within the global Signal program (see below). <br>
 These files have been imported here from vt/ directory (see below).</li></ul>
<p>
<ul>
<li><b>vt</b> Directory used by the Polychrony compiler (code generation: C code, z3z code).</li></ul>
<p>
<ul>
<li><b>vt.PAR</b> parameters of the Signal program.</li></ul>
<p>
<ul>
<li><b>Spec_Liaison.dir</b> Directory that contains the C/JAVA inteface for the simulation.</li></ul>
<p>
<ul>
<li><b>Demo</b> Directory that contains some specific java programs for the simulation.</li></ul>
<p>
Unix:<ul>
<li><b>makeLib</b> script that<ul>
<li>compiles the Signal program automatically produced after the "resolver importation" under polychrony Graphical user Interface,</li><li>then produces the dynamic library for the simulation.</li><li>then generates a dynamic library for simulation (libVTAGVLIB.* file).</li></ul>
</li><li><b>Makefile</b>, <b>Makefile_MacOs</b> makefile description, referenced by makeLib command.</li><li><b>run_demo</b> script used for launching the demo.</li></ul>
<p>
Windows:<ul>
<li><b>makeLib.bat</b> Similar to makeLib for Windows. Generated library: VTAGVLIB.dll</li><li><b>Makefile.win</b> Similar to Makefile for Windows.</li><li><b>run_demo.bat</b> script used for launching the demo.</li></ul>
<h2><a class="anchor" name="sectB">
How to rebuild the complete demo</a></h2>
<ol type=1>
<li>Launch "polychrony" GUI and load vt.gpk file.</li><li>Export le "internal" vt process as a textual file (for example vt.SIG as name).</li><li>Compile the previous vt.SIG program with "z3z" option <br>
 <div class="fragment"><pre class="fragment">		 signal vt.SIG -z3z
                </pre></div> It generates in the sub-directory vt/ the vt.z3z and vt_CMD.z3z files. (Sometimes, some modifications of vt.z3z file is indicated).<ul>
<li>vt.z3z contains the description of the synchronisations of the application. (i.e the polynomial dynmical system encoding the application)</li><li>vt_CMD.z3z contains all the Sigali commands that have been written in the SIGNAL program.</li></ul>
</li><li>Go to the vt subdirectory and call sigali tool execute (under sigali) the following commands <div class="fragment"><pre class="fragment">	       ----------------
	       set_reorder(2); 
               read("vt_CMD.z3z");
               quit();
	       ----------------
	     </pre></div> -&gt; set_reorder(?) perform an automatic reordering of the underlying BDD. For some applications it is better to use set_reorder(1); (another kind of reordering).</li><li>At this point, the files vt.sim and vt.res must have been generated.</li><li>Goto the root directory of the example (i.e. up directory)</li><li>Copy the vt.sim and vt.res (generated in 4) in the "current" directory.</li><li>Under polychrony GUI, goto the vt_<em>Foo</em> process and load the resolver by the following command <br>
 "Tools -&gt; prove -&gt; build_resolv " command.<br>
 After this command, the file vt.SIG.SIG has been generated.<br>
 <b>IMPORTANT:</b> Do not save the program (vt.gpk) after this action (as this program, contains some hidden lines of Signal code that have been automatically added)</li><li>Use the "makeLib" command (see above). This compilation will basically produce a library that will be used further for the JAVA simulation. (The compiler will produce some c files in vt directory...)</li><li>For simulate, execute the command <div class="fragment"><pre class="fragment">                run_demo
              </pre></div></li></ol>
<h2><a class="anchor" name="sectC">
Principles of the technique</a></h2>
This section is a complement to the  <a href="file:J-DEDS.pdf">file:J-DEDS.pdf</a>  publication.<p>
First, remember that the Signal program contains different processes. <br>
 |<br>
 |- CONTEXT: used to perform Simulation <br>
 |<br>
 |- VT_<em>Foo:</em> your application<br>
 |<br>
 |- vt: This process is simply the process VT_<em>Foo</em> to which you add some SIGALI functions and/or some assertions that have to be checked by the inputs. The name is the same for technical reasons than the main program. This is this one that you have to compile in order to obtain the corresponding polynomial dynamical system on which synthesis will be performed.<p>
The last one (<b>vt</b>) is exported in vt.SIG program. This process <b>must</b> have <b>vt</b> as name (see below). It contains SIGALI functions and in particular a call to <b>Simul()</b> SIGALI function.<br>
 For example, the following text is extracted from an example: <div class="fragment"><pre class="fragment">        | (| SIGALI(Controllable(DoorState_Cat_1))
             | SIGALI(Controllable(DoorState_Cat_2))
             | SIGALI(Controllable(DoorState_Cat_3))
             | SIGALI(Controllable(DoorState_Cat_4))
             ...
             | SIGALI(Controllable(DoorState_Mouse_6))
             | SIGALI(S_Security(B_False(Error)))
             | SIGALI(S_Reachable(B_True(Initial_States)))
             | (| b := Simul()
                | SIGALI(b)
                | b ^= DoorState_Cat_1
                |)
             |)
</pre></div> The SIGALI function Simul() is specified by the following declaration <div class="fragment"><pre class="fragment">        process Simul =
             ( ! <span class="keywordtype">boolean</span> RESULT;
             )    
         pragmas 
         SIGALI <span class="stringliteral">""</span>
         COMMENT <span class="stringliteral">"simul(S,nom_fichier1,nom_fichier2)        "</span>
                 <span class="stringliteral">" creates a controller at the right format so that it can be "</span>
                 <span class="stringliteral">" read by the C resolver  function. The result is given by two files"</span>
                 <span class="stringliteral">" nom_fichier1.sim/nom_fichier2.res (Cf. Sigali User-manual for more details)"</span>
         end pragmas
       %Simul%; 
</pre></div> When the compiler is called using the command <em> (signal -tra -z3z vt.SIG) </em>, the file vt_CMD.z3z is created. It contains the following code: <div class="fragment"><pre class="fragment">       read(<span class="stringliteral">"vt.z3z"</span>);
       read(<span class="stringliteral">"Creat_SDP.lib"</span>);
       read(<span class="stringliteral">"Bibli.lib"</span>);
       PROP:B_False(S,Error);
       S : S_Security(S,PROP);
       PROP_721:B_True(S,Initial_States);
       S : S_Reachable(S,PROP_721);
       simul(S,<span class="stringliteral">"vt.res"</span>,<span class="stringliteral">"vt.sim"</span>);
</pre></div> So, the name (<b>vt</b>) used in simul(S,"vt.res","vt.sim"); is the name of the model of the program vt.SIG.<p>
The implementation of the resolver must solve the problem of the connexion between the symbolic variables of the polynomous used to represent the equations and the values of the variables in the C code (during the simulation). The solution consists in (See <a class="el" href="index.html#sectB">here</a>) the generation of files vt.sim and vt.res:<ul>
<li>vt.sim : it contains data for the generating of the simulator (see below): in this file, the symbolic variables are encoded by identifiers.</li><li>vt.res : it contains the data for the resolver and also the TDDs that implement functions and equations of the specification. In this file, the symbolic variables are encoded by integers using the same order than in vt.sim.</li></ul>
<p>
In these files, set of variables are defined <div class="fragment"><pre class="fragment">      $E following by the list of the states
      $Y following by the list of the uncontrolable inputs
      $C following by the list of the conditions
      $O following by the outputs of the controller
</pre></div><p>
<div class="fragment"><pre class="fragment">Example: in the vt.sim file, you can have the following line

$E Cat_Room_4 Mouse_Room_4 Cat_Room_3 Mouse_Room_3 Cat_Room_2 Mouse_Room_2 Cat_Room_1 Mouse_Room_1 Cat_Room_0 Mouse_Room_0 
states_1 states_2 states_3 states_4 states_6 states_8 states_9 states_10 states_11 states_12

and in the vt.res file, you can have the following line

$E 15 34 9 41 14 24 8 35 0 31 1 3 18 5 16 25 36 32 44 40
</pre></div><p>
When the user executes the command (under the GUI of Polychrony) <em> Tools -&gt; prove -&gt; build_resolv </em> on the model called VT_<em>Foo</em>, Polychrony integrates automatically some SIGNAL code in this model by <b>analyzing</b> the file vt.sim (<em> this name is predefined in the software, it is the reason why this name (vt) is important </em>).<p>
In this model (VT_<em>Foo</em>) there is a model RESOLVER that references the external resolver (resolver model). The Signal code of the RESOLVER model is : <div class="fragment"><pre class="fragment">     process RESOLVER =
           { integer ncond, nx, nu, ny; }
           ( ? [ncond]integer cod_cond;
               [nx]integer cod_x;
               event TTick;
             ! [nu]integer cod_u;
               [ny]integer cod_y;
               event Tick;
           )
         (| (| (| S_cod_cond := cod_cond cell TTick
                | S_cod_x := cod_x cell TTick
                | resolver{}
                |)
             | (| Z_S_cod_u := S_cod_u$1 init [{i to nu}:0]
                | cod_u := Z_S_cod_u when Tick
                | Z_S_cod_y := S_cod_y$1 init [{i to ny}:0]
                | cod_y := Z_S_cod_y when Tick
                |)
             | (| (| b := (when fin_resolver) <span class="keywordflow">default</span> <span class="keyword">false</span>
                   | z_b := b$1
                   | b ^= TTick
                   |)
                | Tick := when z_b
                |)
             |) |)
         where 
         <span class="keywordtype">boolean</span> z_b init <span class="keyword">true</span>, b;
         [nx]integer S_cod_x;
         [nu]integer S_cod_u;
         [nu]integer Z_S_cod_u;
         [ny]integer S_cod_y;
         [ny]integer Z_S_cod_y;
         [ncond]integer S_cod_cond;
         <span class="keywordtype">boolean</span> fin_resolver;
         process resolver =
              ( ? [ncond]integer S_cod_cond;
                  [nx]integer S_cod_x;
                ! [nu]integer S_cod_u;
                  [ny]integer S_cod_y;
                  <span class="keywordtype">boolean</span> fin_resolver;
              )
              spec (| S_cod_cond ^= S_cod_x ^= S_cod_u ^= S_cod_y ^= fin_resolver |)
         
         ; 
         end ; 
</pre></div><p>
The generation consists in<ul>
<li>the calling of the RESOLVER model by fixing the values of the parameters (ncond, nx, nu, ny) and the definition of the inputs (cod_cond, cod_x). TTick is the master clock of the program.</li><li>the definition of the outputs from the returned values by the RESOLVER (cod_u, cod_y). Tick is the clock at which the outputs are available.</li></ul>
<p>
All these informations are extracted from the vt.sim files. For examples,<p>
<ul>
<li>For a variable Mvt_Mouse_1 that appears in the set ($Y) of vt.sim , the following definition is produced <div class="fragment"><pre class="fragment">         Mvt_Mouse_1 := (<span class="keyword">true</span> when (cod_y[0]=1)) <span class="keywordflow">default</span> (<span class="keyword">false</span> when (cod_y[0]=(-1))) <span class="keywordflow">default</span> <span class="keyword">false</span>
</pre></div></li><li>For a variable DoorState_Cat_3 that appears in the set ($O) of vt.sim, the following definition is produced <div class="fragment"><pre class="fragment">         DoorState_Cat_3 := (<span class="keyword">true</span> when (cod_u[2]=1)) <span class="keywordflow">default</span> (<span class="keyword">false</span> when (cod_u[2]=(-1))) <span class="keywordflow">default</span> <span class="keyword">false</span>
</pre></div></li><li>For a state variable Ci that appears in the set ($E) at the i-th rank of vt.sim, the following definition is produced INTERMi := (1 when Ci default (2 when (not Ci)) default (0 when Tick) and you will find INTERMi as the i-th element in the definition of cod_x <div class="fragment"><pre class="fragment">          cod_x := [[0] : INTERM0, ... [i] : INTERMi, ...]
</pre></div> </li></ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Oct 6 09:19:51 2006 for AAREADME by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
