Contents:\begin{itemize}
\item {\bf Directory contents}{\rm (p.\,\pageref{index_sectA})}\item {\bf How to rebuild the complete demo}{\rm (p.\,\pageref{index_sectB})}\end{itemize}
\section{Directory contents}\label{index_sectA}
In this directory, you will find the following files and directory:

\begin{itemize}
\item {\bf AAREADME} The directory of the documentation.\end{itemize}


\begin{itemize}
\item {\bf vt.gpk} is the main Signal file. It has to be loaded by the graphical user interface \char`\"{}polychrony\char`\"{}. This Signal program contains different processes. \par
 $|$\par
 $|$- CONTEXT: used to perform Simulation \par
 $|$\par
 $|$- VT\_\-{\em Foo:\/} your application\par
 $|$\par
 $|$- vt: This process is simply the process VT\_\-{\em Foo\/} to which you add some SIGALI functions and/or some assertions that have to be checked by the inputs. The name is the same for technical reasons than the main program. This is this one that you have to compile in order to obtain the corresponding polynomial dynamical system on which synthesis will be performed.\end{itemize}


\begin{itemize}
\item {\bf vt.sim}, {\bf vt.res} are file generated by Sigali in order to perform simulation. They contains in a internal format the result of the sigali computations (i.e. the controller). They will be used by the polychrony tool to encapsulate the controller within the global Signal program (see below). \par
 These files have been imported here from vt/ directory (see below).\end{itemize}


\begin{itemize}
\item {\bf vt} Directory used by the Polychrony compiler (code generation: c code, z3z code).\end{itemize}


\begin{itemize}
\item {\bf vt.PAR} Signal program parameters.\end{itemize}


\begin{itemize}
\item {\bf Spec\_\-Liaison.dir} Directory that contains the C/JAVA inteface for the simulation.\end{itemize}


\begin{itemize}
\item {\bf Demo} Directory that contains some specific java programs for the simulation.\end{itemize}


\begin{itemize}
\item {\bf vt.SIG.SIG} generated Signal program (with the resolver), see {\bf How to rebuild the complete demo}{\rm (p.\,\pageref{index_sectB})}.\end{itemize}


Unix:

\begin{itemize}
\item {\bf make\-Lib} script that\begin{itemize}
\item compiles the Signal program automatically produced after the \char`\"{}resolver importation\char`\"{} under polychrony Graphical user Interface,\item then produces the dynamic library for the simulation.\item then generates a dynamic library for simulation (lib\-VTAGVLIB.$\ast$ file).\end{itemize}
\item {\bf Makefile},Makefile\_\-Mac\-Os: makefile description, referenced by make\-Lib command.\item {\bf run\_\-demo} script used for launching the demo.\end{itemize}


Windows:\begin{itemize}
\item {\bf make\-Lib.bat} Similar to make\-Lib for Windows. Generated library: VTAGVLIB.dll\item {\bf Makefile.win} Similar to Makefile for Windows.\item {\bf run\_\-demo.bat} script used for launching the demo.\end{itemize}
\section{How to rebuild the complete demo}\label{index_sectB}
\begin{enumerate}
\item Launch \char`\"{}polychrony\char`\"{} GUI and load vt.gpk file.\item Export le \char`\"{}internal\char`\"{} vt process as a textual file (for example vt.SIG as name).\item Compile the previous vt.SIG program with \char`\"{}z3z\char`\"{} option \par
 

\footnotesize\begin{verbatim}		 signal vt.SIG -z3z
                \end{verbatim}
\normalsize
 It generates in the sub-directory vt/ the vt.z3z and vt\_\-CMD.z3z files. See {\bf here for some modifications of vt.z3z file}{\rm (p.\,\pageref{note})}.\begin{itemize}
\item vt.z3z contains the description of the synchronisations of the application. (i.e the polynomial dynmical system encoding the application)\item vt\_\-CMD.z3z contains all the Sigali commands that have been written in the SIGNAL program.\end{itemize}
\item Go to the vt subdirectory and call sigali tool execute (under sigali) the following commands 

\footnotesize\begin{verbatim}	       ----------------
	       set_reorder(2); 
               read("vt_CMD.z3z");
               quit();
	       ----------------
	     \end{verbatim}
\normalsize
 -$>$ set\_\-reorder(?) perform an automatic reordering of the underlying BDD. For some applications it is better to use set\_\-reorder(1); (another kind of reordering).\item At this point, the files vt.sim and vt.res must have been generated.\item Goto the root directory of the example (i.e. up directory)\item Copy the vt.sim and vt.res (generated in 4) in the \char`\"{}current\char`\"{} directory.\item Under polychrony GUI, goto the vt\_\-{\em Foo\/} process and load the resolver by the following command \par
 \char`\"{}Tools  $\rightarrow$  prove  $\rightarrow$  build\_\-resolv \char`\"{} command.\par
 After this command, the file {\bf vt.SIG.SIG} has been generated.\par
 {\bf IMPORTANT:} Do not save the program (vt.gpk) after this action (as this program, contains some hidden lines of Signal code that have been automatically added)\item Use the \char`\"{}make\-Lib\char`\"{} command (see above). This compilation will basically produce a library that will be used further for the JAVA simulation. (The compiler will produce some C files in vt directory...)\item For simulate, execute the command 

\footnotesize\begin{verbatim}                run_demo
              \end{verbatim}
\normalsize
 \end{enumerate}
